function Mcl_Poly_Ctor_Output = Mcl_Poly_Ctor(Xcell, Xtrans, Rank, ForceEqualPriors, Nquantiles, DisplayModulus, OptNapproaches)

% function out = Mcl_Poly_Ctor(Xcell, Xtrans, Rank, ForceEqualPriors, Nquantiles, DisplayModulus, OptNapproaches)
% This constructs a new Mcl_Poly classifier.  This function initializes the classifier and utilizes the mex function
%	Mcl_Poly_Init. After initialization, the classifier can be trained by calling the Mcl_Train function.  Finally,
%	after training, the classifier can be used to classify new data using Mcl_Classify.
%--------------------------------------------------------------------------------------------------------------------------------
% NOMENCLATURE (for interpreting subsequent comments)
%----------------------------------------------------
% nCats = The number of categories (i.e. the length of the input X cell array)
% nSamp(iCat) = The number of training samples in each category (i.e. the number of rows of the input X{iCat} summed across all iCat).
% ntSamp = The total number of training samples = sum(nSamp);
% nDims = The spatial dimension of the data (i.e. the number of columns for each input X{iCat}, this is the same for each iCat).
%--------------------------------------------------------------------------------------------------------------------------------
% INPUT (values are not altered by mex function)
%----------------------------------------------------
% Xcell (cell vector: nCats)
%  Each iCat element of this cell array, Xcell{iCat}, is a 2D array (nSamp(iCat),nDims) contains samples of training data from category iCat.
%
% [Xtrans] Optional (matlab structure Mcl_Trfm array: nDims)
%  Each spatial dimension can be associated with a transform.  The contents of Xcell are transformed accordingly before the classifier
%	is initialized.  You can also leave this argument empty [] and no transforms will be applied.
%
% Rank (int32 scalar) Defaults to 1.
%	A positive integer identifying the polynomial rank.  Flat=0, Linear=1, Quadratic=2, Cubic=3, ...	
%
% ForceEqualPriors (bool scalar) Defaults to true.
%	If true, then the categories are assumed to have equal prior probabilities, even if there are different numbers of samples for
%	each category in the training data.
%
% Nquantiles (int32 scalar) Defaults to min(20,ceil(ntSamp/20)).  Suggest any integers from 10 to 50.
%	The number of quantiles to be used in estimating the probability of category membership based on each cateogory's decision variable.
%	In general, a good value for Nquantiles is 30.
%
% DisplayModulus (int32 scalar) Defaults to 2500.  If 0 or negative, messages will not be displayed.
%	If positive, messages will be displayed and out.SolverOptions.DisplayModulus will be set to DisplayModulus.
%	
% OptNapproaches (int32 scalar) Defaults to 1.
%	If 0 or negative, solver will not be optimized.  If positive, the solver is optimized with out.SolverOptions.Napproaches set equal to OptNapproaches.

global Mcl_Poly_Ctor_Output

nCats = numel(Xcell);
if nCats<2
	error('There must be at least 2 categories of data.  Xcell must have more elements.');
end
nDims = size(Xcell{1},2);
nSamp = zeros(1,nCats);
for iCat=1:nCats
	nSamp(iCat) = size(Xcell{iCat},1);
end
ntSamp = sum(nSamp);
nPoly = nCats;
if nCats==2
	nPoly = 1;
end

%	Implement default behavior
if ~exist('OptNapproaches', 'var') || isempty(OptNapproaches)
	OptNapproaches=1;
end
if ~exist('DisplayModulus', 'var') || isempty(DisplayModulus)
	DisplayModulus = 2500;
end
if ~exist('Nquantiles', 'var') || isempty(Nquantiles)
	Nquantiles = min(20,ceil(ntSamp/20));
end
if ~exist('ForceEqualPriors', 'var') || isempty(ForceEqualPriors)
	ForceEqualPriors = true;
end
if ~exist('Rank', 'var') || isempty(Rank)
	Rank = 1;
end

%	Get the polynomial coefficients
[Ncoeff, NcoeffByRank, CoeffDims] = Mcl_Poly_Coeff(int32(Rank),int32(nDims));

%	Play it safe:  Allocate all memory in M-file, not Mex-File.  This protects against funny business with Matlab's memory manager.
Mcl_Poly_Ctor_Output = struct(...
	'Class', 'Mcl_Poly', ...
	'Ncats', int32(nCats), ...
	'Ndims', int32(nDims), ...
	'IdDims', zeros(1,nDims,'int32'), ... % Globally unique identifiers for each stimulus dimension.
	'Ntsamp', int32(ntSamp), ...
	'Nsamp', int32(nSamp), ...
	'Npoly', int32(nPoly), ...
	'Rank', int32(Rank), ...
	'Ncoeff', int32(Ncoeff), ... % The total number of polynomial coefficients, also equal to sum(Ntens).
	'NcoeffByRank', int32(NcoeffByRank), ... % The number of polynomial coefficients at each rank.
	'CoeffDims', int32(CoeffDims), ... % (int32 2D array, Ncoeff * Rank)  Defines each coefficient by pointing to the spatial dimension(s) over which it operates.  -1 is a placeholder for empty dimensions.
	'ForceEqualPriors', logical(ForceEqualPriors), ...
	'CatWeight', zeros(nCats,1), ...
	'Cat', zeros(ntSamp,1,'int32'), ...
	'Xtrans', Xtrans, ...
	'X', zeros(ntSamp,Ncoeff), ...
	'Xmeans', zeros(nCats,Ncoeff), ...
	'Xvars', zeros(nCats,Ncoeff), ...
	'Xmean', zeros(1,Ncoeff), ...
	'Xvar', zeros(1,Ncoeff), ...
	'Xscale', zeros(nCats,Ncoeff), ...
	'Xacc', zeros(nCats,Ncoeff), ...
	'wScale', zeros(Ncoeff,nPoly), ...
	'wInit', NaN(Ncoeff,nPoly), ...
	'wOptimized', zeros(Ncoeff,nPoly), ...
	'Dv', zeros(ntSamp,nCats), ...
	'P', zeros(ntSamp,nCats), ...
	'H', zeros(ntSamp,1), ...
	'h', 0, ...
	'Hcross', zeros(nCats,nCats), ...
	'Acc', 0, ...
	'ConfusionMatrix', zeros(nCats,nCats), ...
	'DisplayModulus', DisplayModulus, ...
	'Quant', [], ...
	'SolverOptions', Mcl_MinimizeEntropy('OPTIONS'), ...
	'SolverOutput', [] );

pLow = 0.25/nCats/(ntSamp/Nquantiles);
pHigh = 1-(nCats-1)*pLow;
for iCat=1:nCats
	Mcl_Poly_Ctor_Output.Quant = [Mcl_Poly_Ctor_Output.Quant, ...
		struct(...
			'Class', 'Mcl_QuantizedDv', ...
			'Nquantiles', int32(Nquantiles), ...
			'Dv', zeros(Nquantiles,1), ...
			'DvBinSep', zeros(Nquantiles+1,1), ...
			'Weight', zeros(Nquantiles,1), ...
			'Pc', zeros(Nquantiles,1), ...
			'PcMono', zeros(Nquantiles,1), ...
			'PcMonoLim', zeros(Nquantiles,1), ...
			'pLow', pLow, ...
			'pHigh', pHigh, ...
			'hMin', -log(1-(nCats-1)*pLow) / log(nCats)...
		) ];
end

%	Apply transforms of the spatial dimensions
if ~isempty(Xtrans)
	Xcell = Mcl_Trfm_Cols(Xtrans,true,Xcell);
end
%	Calculate initial representation in the structure.
Mcl_Poly_Init(Mcl_Poly_Ctor_Output, Xcell);
%	Configure entropy minimization solver
Mcl_Poly_Ctor_Output.SolverOptions.DisplayModulus = DisplayModulus;
Mcl_Poly_Ctor_Output.SolverOptions.wShrinkFactor = 2;
Mcl_Poly_Ctor_Output.SolverOptions.wDiffMax = sqrt(double(  nPoly*Ncoeff  )) * max(abs(Mcl_Poly_Ctor_Output.wInit(:)./Mcl_Poly_Ctor_Output.wScale(:)));
Mcl_Poly_Ctor_Output.SolverOptions.wDiffTol = 0.0001*Mcl_Poly_Ctor_Output.SolverOptions.wDiffMax;
Mcl_Poly_Ctor_Output.SolverOptions.hTol = 0.0001;
Mcl_Poly_Ctor_Output.SolverOptions.Napproaches = max(1,OptNapproaches);
%	Optimize
if OptNapproaches>0
	Mcl_Poly_Ctor_Output = Mcl_Poly_Train(Mcl_Poly_Ctor_Output);
end